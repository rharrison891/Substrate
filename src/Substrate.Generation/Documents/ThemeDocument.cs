using Substrate.Generation.Core.Helpers;
using Substrate.Generation.Core.Nodes;

using System.Text;

namespace Substrate.Generation.Core.Documents
{
    internal sealed class ThemeDocument : DocumentBase
    {
        private readonly TypeKey _key;
        private readonly ThemeNode _theme;

        public ThemeDocument(TypeKey key, IReadOnlyList<SubstrateNode> themeNodes)
            : base(DocumentHelpers.GetHintName(key))
        {
            _key = key;
            _theme = (ThemeNode)themeNodes.FirstOrDefault();
        }

        public override string Build()
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// Substrate.Theme");
            sb.AppendLine();
            sb.Nullable();
            sb.BlankLine();

            // üîπ All usings live here ‚Äî once.
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Windows.Markup;");
            sb.AppendLine("using System.Windows.Media;");
            sb.BlankLine();

            if (!string.IsNullOrEmpty(_key.Namespace))
            {
                sb.AppendLine($"namespace {_key.Namespace};");
                sb.BlankLine();
            }

            // 1Ô∏è‚É£ Enum
            ThemeEnumEmitter.Build(sb, _theme);
            sb.BlankLine();

            // 2Ô∏è‚É£ Theme class
            ThemeClassEmitter.Build(sb, _theme);
            sb.BlankLine();

            // 3Ô∏è‚É£ Markup extension
            ThemeMarkupEmitter.Build(sb, _theme);

            return sb.ToString();
        }
    }
    internal static class ThemeEnumEmitter
    {
        public static void Build(StringBuilder sb, ThemeNode node)
        {
            sb.AppendLine("public enum ThemeColor");
            sb.AppendLine("{");

            foreach (var c in node.Colors)
                sb.AppendLine($"    {c.Key},");

            sb.AppendLine("}");
        }
    }
    internal static class ThemeClassEmitter
    {
        public static void Build(StringBuilder sb, ThemeNode node)
        {
            sb.AppendLine($"public static partial class {node.TypeName}");
            sb.OpenBrace(0);

            BuildBaseColorTable(sb, node);
            BuildBrushHelpers(sb);
            BuildSetters(sb);
            BuildConvenienceAccessors(sb, node);

            sb.CloseBrace(0);
        }

        private static void BuildBaseColorTable(StringBuilder sb, ThemeNode node)
        {
            sb.AppendLine("    private static readonly Dictionary<ThemeColor, Color> BaseColors = new()");
            sb.AppendLine("    {");

            foreach (var c in node.Colors)
                sb.AppendLine(
                    $"        [ThemeColor.{c.Key}] = Color.FromArgb({c.A}, {c.R}, {c.G}, {c.B}),");

            sb.AppendLine("    };");
            sb.BlankLine();
        }

        private static void BuildBrushHelpers(StringBuilder sb)
        {
            sb.AppendLine("    private static readonly Dictionary<string, SolidColorBrush> __cache = new();");
            sb.BlankLine();

            sb.AppendLine(
        @"    public static Color GetColor(ThemeColor c) => BaseColors[c];

    public static SolidColorBrush GetBrush(ThemeColor color, double alpha = 1.0, double brightness = 0.0)
    {
        string key = $""{color}:{alpha}:{brightness}"";
        if (__cache.TryGetValue(key, out var b))
            return b;

        var c = GetColor(color);

        byte A = (byte)Math.Clamp(c.A * alpha, 0, 255);
        byte R = (byte)Math.Clamp(c.R + brightness, 0, 255);
        byte G = (byte)Math.Clamp(c.G + brightness, 0, 255);
        byte B = (byte)Math.Clamp(c.B + brightness, 0, 255);

        var brush = new SolidColorBrush(Color.FromArgb(A, R, G, B));

        __cache[key] = brush;
        return brush;
    }");

            sb.BlankLine();
        }

private static void BuildSetters(StringBuilder sb)
{
    sb.AppendLine(
@"    public static void SetColor(ThemeColor key, Color value)
    {
        BaseColors[key] = value;

        // Update any cached brushes that depend on this ThemeColor
        foreach (var pair in __cache)
        {
            var cacheKey = pair.Key;      // e.g. Blue:1:0
            var brush    = pair.Value;

            var parts = cacheKey.Split(':');
            if (parts.Length != 3)
                continue;

            if (!Enum.TryParse<ThemeColor>(parts[0], out var colorKey))
                continue;

            if (colorKey != key)
                continue;

            double alpha = 1.0;
            double brightness = 0.0;

            double.TryParse(parts[1], System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture, out alpha);

            double.TryParse(parts[2], System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture, out brightness);

            byte A = (byte)Math.Clamp(value.A * alpha, 0, 255);
            byte R = (byte)Math.Clamp(value.R + brightness, 0, 255);
            byte G = (byte)Math.Clamp(value.G + brightness, 0, 255);
            byte B = (byte)Math.Clamp(value.B + brightness, 0, 255);

            brush.Color = Color.FromArgb(A, R, G, B);
        }
    }

    public static void SetColor(ThemeColor key, string hex)
    {
        if (!TryParseHex(hex, out int a, out int r, out int g, out int b))
            throw new ArgumentException(""Invalid color value."", nameof(hex));

        SetColor(key, Color.FromArgb((byte)a, (byte)r, (byte)g, (byte)b));
    }

    private static bool TryParseHex(string expr, out int a, out int r, out int g, out int b)
    {
        a = r = g = b = 0;
        expr = expr.Trim().Trim('""');

        if (expr.StartsWith(""#""))
            expr = expr.Substring(1);

        if (expr.Length == 6)
        {
            a = 255;
            r = Convert.ToInt32(expr.Substring(0, 2), 16);
            g = Convert.ToInt32(expr.Substring(2, 2), 16);
            b = Convert.ToInt32(expr.Substring(4, 2), 16);
            return true;
        }

        if (expr.Length == 8)
        {
            a = Convert.ToInt32(expr.Substring(0, 2), 16);
            r = Convert.ToInt32(expr.Substring(2, 2), 16);
            g = Convert.ToInt32(expr.Substring(4, 2), 16);
            b = Convert.ToInt32(expr.Substring(6, 2), 16);
            return true;
        }

        return false;
    }");

    sb.BlankLine();
}

        private static void BuildConvenienceAccessors(StringBuilder sb, ThemeNode node)
        {
            foreach (var c in node.Colors)
            {
                sb.AppendLine($"    public static SolidColorBrush {c.Key}Brush => GetBrush(ThemeColor.{c.Key});");
                sb.AppendLine($"    public static Color {c.Key} => GetColor(ThemeColor.{c.Key});");
            }
        }
    }
    internal static class ThemeMarkupEmitter
    {
        public static void Build(StringBuilder sb, ThemeNode node)
        {

            sb.AppendLine("[MarkupExtensionReturnType(typeof(Brush))]");
            sb.AppendLine("public class ThemeBrushExtension : MarkupExtension");
            sb.OpenBrace(0);

            sb.AppendLine("    public ThemeColor Base { get; set; }");
            sb.AppendLine("    public double Alpha { get; set; } = 1.0;");
            sb.AppendLine("    public double Brightness { get; set; } = 0.0;");
            sb.BlankLine();

            sb.AppendLine(
    $@"    public override object ProvideValue(IServiceProvider sp)
    {{
        return {node.TypeName}.GetBrush(Base, Alpha, Brightness);
    }}");

            sb.CloseBrace(0);
        }
    }
}
