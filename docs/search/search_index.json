{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#substrate","title":"Substrate","text":"<p>Tools &amp; automation for developers and businesses.</p>"},{"location":"#why-substrate","title":"Why Substrate?","text":"<ul> <li>Reduces boilerplate</li> <li>Automates repetitive UI tasks</li> <li>Keeps code clean and maintainable</li> </ul>"},{"location":"notify/","title":"Notify Attribute","text":"<p>The [Notify] attribute generates boilerplate for property change notification, so you don\u2019t have to manually write INotifyPropertyChanged logic. It is designed for MVVM scenarios where you want clean view-models without repeating the same patterns.</p>"},{"location":"notify/#what-it-does","title":"\u2728 What it does","text":"<p>Normally you would write:</p> <pre><code>public class Person : INotifyPropertyChanged { private string _name;\npublic string Name\n{\n    get =&gt; _name;\n    set\n    {\n        if (_name == value) return;\n\n        _name = value;\n        OnPropertyChanged(nameof(Name));\n    }\n}\npublic event PropertyChangedEventHandler? PropertyChanged;\nprotected void OnPropertyChanged(string propertyName)\n    =&gt; PropertyChanged?.Invoke(this, new(propertyName));\n}\n</code></pre> <p>With [Notify], you simply declare the backing field:</p> <pre><code>public partial class Person \n{ \n    [Notify] \n    private string _name; \n} \n</code></pre> <p>The generator creates the property, backing logic, and notification code automatically.</p>"},{"location":"notify/#benefits","title":"\ud83c\udfaf Benefits","text":"<p>No duplicated OnPropertyChanged code Strongly-typed, compiler-generated properties Easier refactoring (rename the field \u2192 property updates automatically) Less noise in your view-models</p>"},{"location":"notify/#generated-property","title":"\ud83d\udd0e Generated property","text":"<p>From the field: <code>[Notify] private string _name;</code> The generator produces something like:</p> <pre><code>public string Name { \n    get =&gt; _name; \n    set \n    { \n        if (_name == value) return;\n        _name = value;\n        OnPropertyChanged(nameof(Name));\n    }\n} \n</code></pre> <p>The exact output may vary slightly, but the behavior is always the same.</p>"},{"location":"notify/#notes","title":"\ud83d\udccc Notes","text":"<p>Works in any class marked partial Requires INotifyPropertyChanged support in your base type Generated code is placed in a .g.cs file \u2014 do not edit it</p>"},{"location":"notify/#how-notify-works","title":"\ud83d\udcc4 How Notify Works","text":"<p>When you mark a backing field with <code>[Notify]</code>, the generator:</p> <ul> <li>Ensures the type implements <code>INotifyPropertyChanged</code></li> <li>Generates a public property for the field</li> <li>Raises 'OnPropertyChanged' when the value changes</li> <li>Skips notifications when the value hasn\u2019t changed</li> <li>(Optional) generates strongly-typed change hooks</li> </ul> <p>If hooks are enabled for the field, the following methods are available:</p> <ul> <li><code>OnXChanging(oldValue, ref newValue, ref cancel)</code></li> <li><code>OnXChanged(oldValue, newValue)</code></li> </ul> <p>Use these to:</p> <ul> <li>validate and cancel changes</li> <li>modify the incoming value (coercion)</li> <li>react to changes after assignment</li> </ul> <p>The final property change event is raised only after the value is successfully updated.</p>"}]}