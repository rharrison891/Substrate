{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Substrate","text":""},{"location":"#a-generator-suite-for-net","title":"A generator suite for .Net.","text":"<p>Substrate is the answer to the question</p> <p>\"Why is WPF so complicated?\"</p> <p>WPF itself is an incredibly powerful platform that offers developers a real way to express themselves. A highly developed environment where almost everything can be customised. </p> <ul> <li>Chrome windows</li> <li>Custom controls</li> <li>Templating</li> <li>Animation</li> <li>Effects</li> </ul> <p>The problems start when you actually try to implement any of these. The amount of standardised coding required to make these work stops most of us ever actually using WPF to it's full potential.</p> <p>MVVM has developed as its own ecosystem to help take some of the pain away, and other generator packages have simplified that for us. But that is a small piece of the problem. We still have</p> <ul> <li>Dependency properties</li> <li>Xaml themes</li> <li>Validation </li> <li>Confusing font systems</li> </ul>"},{"location":"#why-substrate","title":"Why Substrate?","text":"<p>Substrate exists to remove that pain - making these tasks simple, predictable, and fast. Our aim is for no unnecessary boilerplate needed...Ever.</p> <ul> <li>Reduces boilerplate to almost nothing</li> <li>Automates repetitive UI tasks</li> <li>Keeps code clean and maintainable</li> </ul>"},{"location":"#whats-in-the-package","title":"What's in the package","text":"<p>This is a short list of what is already included, along with future plans</p> <ul> <li> <p> Notify </p> <p>Automatic configuration of <code>INotifyPropertyChanged</code></p> </li> <li> <p> Dependency Property</p> <p>Easy wiring for different types of dependency properties</p> </li> <li> <p> Control</p> <p>Generate complete controls completely from Xaml</p> </li> <li> <p> Theme</p> <p>Global theme generation from a single dictionary</p> </li> <li> <p> Icons</p> <p>A complete set of all Fluent icon glyphs</p> </li> <li> <p> Fonts</p> <p>Custom fonts without all the usual fuss</p> </li> </ul> <p>These are already in production, and others will be coming soon. If you constantly find yourself writing the same code over and over, let us know. If it's repetitive, it's reproducible - and Substrate will automate it.</p>"},{"location":"notify/","title":"Notify Attribute","text":"<p>The [Notify] attribute generates boilerplate for property change notification, so you don\u2019t have to manually write INotifyPropertyChanged logic. It is designed for MVVM scenarios where you want clean view-models without repeating the same patterns.</p>"},{"location":"notify/#what-it-does","title":"\u2728 What it does","text":"<p>Normally you would write: <pre><code>public class Person : INotifyPropertyChanged { private string _name;\npublic string Name\n{\n    get =&gt; _name;\n    set\n    {\n        if (_name == value) return;\n\n        _name = value;\n        OnPropertyChanged(nameof(Name));\n    }\n}\npublic event PropertyChangedEventHandler? PropertyChanged;\nprotected void OnPropertyChanged(string propertyName)\n    =&gt; PropertyChanged?.Invoke(this, new(propertyName));\n}\n</code></pre> With [Notify], you simply declare the backing field: <pre><code>public partial class Person \n{ \n    [Notify] \n    private string _name; \n} \n</code></pre> The generator creates the property, backing logic, and notification code automatically.</p>"},{"location":"notify/#benefits","title":"\ud83c\udfaf Benefits","text":"<p>No duplicated OnPropertyChanged code Strongly-typed, compiler-generated properties Easier refactoring (rename the field \u2192 property updates automatically) Less noise in your view-models</p>"},{"location":"notify/#generated-property","title":"\ud83d\udd0e Generated property","text":"<p>From the field: <code>[Notify] private string _name;</code> The generator produces something like: <pre><code>public string Name { \n    get =&gt; _name; \n    set \n    { \n        if (_name == value) return;\n        _name = value;\n        OnPropertyChanged(nameof(Name));\n    }\n} \n</code></pre> The exact output may vary slightly, but the behavior is always the same.</p>"},{"location":"notify/#notes","title":"\ud83d\udccc Notes","text":"<p>Works in any class marked partial Requires INotifyPropertyChanged support in your base type Generated code is placed in a .g.cs file \u2014 do not edit it</p>"},{"location":"notify/#how-notify-works","title":"\ud83d\udcc4 How Notify Works","text":"<p>When you mark a backing field with <code>[Notify]</code>, the generator:</p> <ul> <li>Ensures the type implements <code>INotifyPropertyChanged</code></li> <li>Generates a public property for the field</li> <li>Raises 'OnPropertyChanged' when the value changes</li> <li>Skips notifications when the value hasn\u2019t changed</li> <li>(Optional) generates strongly-typed change hooks</li> </ul> <p>If hooks are enabled for the field, the following methods are available:</p> <ul> <li><code>OnXChanging(oldValue, ref newValue, ref cancel)</code></li> <li><code>OnXChanged(oldValue, newValue)</code></li> </ul> <p>Use these to:</p> <ul> <li>validate and cancel changes</li> <li>modify the incoming value (coercion)</li> <li>react to changes after assignment</li> </ul> <p>The final property change event is raised only after the value is successfully updated.</p>"}]}