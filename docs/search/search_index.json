{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Substrate","text":""},{"location":"#a-generator-suite-for-net","title":"A generator suite for .Net.","text":"<p>Substrate is the answer to the question</p> <p>\"Why is WPF so complicated?\"</p> <p>WPF itself is an incredibly powerful platform that offers developers a real way to express themselves. A highly developed environment where almost everything can be customised. </p> <ul> <li>Chrome windows</li> <li>Custom controls</li> <li>Templating</li> <li>Animation</li> <li>Effects</li> </ul> <p>The problems start when you actually try to implement any of these. The amount of standardised coding required to make these work stops most of us ever actually using WPF to it's full potential.</p> <p>MVVM has developed as its own ecosystem to help take some of the pain away, and other generator packages have simplified that for us. But that is a small piece of the problem. We still have</p> <ul> <li>Dependency properties</li> <li>Xaml themes</li> <li>Validation </li> <li>Confusing font systems</li> </ul>"},{"location":"#why-substrate","title":"Why Substrate?","text":"<p>Substrate exists to remove that pain - making these tasks simple, predictable, and fast. Our aim is for no unnecessary boilerplate needed...Ever.</p> <ul> <li>Reduces boilerplate to almost nothing</li> <li>Automates repetitive UI tasks</li> <li>Keeps code clean and maintainable</li> </ul>"},{"location":"#whats-in-the-package","title":"What's in the package","text":"<p>This is a short list of what is already included, along with future plans</p> <ul> <li> <p> Notify </p> <p>Automatic configuration of <code>INotifyPropertyChanged</code></p> </li> <li> <p> Dependency Property</p> <p>Easy wiring for different types of dependency properties</p> </li> <li> <p> Control</p> <p>Generate complete controls completely from Xaml</p> </li> <li> <p> Theme</p> <p>Global theme generation from a single dictionary</p> </li> <li> <p> Icons</p> <p>A complete set of all Fluent icon glyphs</p> </li> <li> <p> Fonts</p> <p>Custom fonts without all the usual fuss</p> </li> </ul> <p>These are already in production, and others will be coming soon. If you constantly find yourself writing the same code over and over, let us know. If it's repetitive, it's reproducible - and Substrate will automate it.</p>"},{"location":"features/","title":"Features &amp; Roadmap","text":"<p>Substrate focuses on removing repetitive WPF boilerplate so developers can spend more time designing UI and less time wiring plumbing.</p>"},{"location":"features/#current-features","title":"\u2705 Current features","text":"<ul> <li> <code>Notify</code> \u2014 automatic INotifyPropertyChanged</li> <li> Dependency Property generator</li> <li> Theme generator</li> <li> Fluent icon mapping</li> <li> Custom font support</li> <li> Docs powered by MkDocs</li> </ul>"},{"location":"features/#in-progress","title":"\ud83d\udee0 In progress","text":"<ul> <li> Control generator from XAML templates</li> <li> Navigation + DI (prototype)</li> <li> <code>[Report]</code> developer feedback system</li> <li> Achievement / Easter-egg framework</li> </ul>"},{"location":"features/#planned-ideas","title":"\ud83c\udf31 Planned ideas","text":"<ul> <li> Visual Studio wizard (VSIX)</li> <li> Theme designer UI</li> <li> XAML parser improvements</li> <li> Better validation helpers</li> <li> Converter helpers</li> </ul> <p>If something is missing \u2014 open an issue or suggest it in the docs!</p>"},{"location":"icons/","title":"IconPack","text":""},{"location":"icons/#a-complete-set-of-fluent-icons","title":"A complete set of Fluent Icons","text":"<p>All of the icons are available through the source generator and can be included with a simple <code>[IconPack]</code> attribute.</p> <p>This generates:</p> <ul> <li><code>Icons</code> enum with \u2248 1,500 icons  </li> <li><code>IconMap</code> dictionary to convert enum \u2192 glyph  </li> <li><code>AsGlyph()</code> extension method  </li> <li><code>Get()</code> accessor</li> </ul> <p>To activate, create a blank partial class:</p> <pre><code>[IconPack]\npublic partial class AppIcons { }\n</code></pre> <p>That's it - The generator will do the rest, and Icons are now available globally.</p>"},{"location":"icons/#using-an-icon","title":"Using an icon","text":"<pre><code>&lt;TextBlock FontFamily=\"Segoe MDL2 Assets\"\n           Text=\"{x:Static local:Icons.Save.AsGlyph}\" /&gt;\n</code></pre> <p>or in C#:</p> <pre><code>var glyph = Icons.Save.AsGlyph();\n</code></pre>"},{"location":"notify/","title":"Notify Attribute","text":"<p>The [Notify] attribute generates boilerplate for property change notification, so you don\u2019t have to manually write INotifyPropertyChanged logic. It is designed for MVVM scenarios where you want clean view-models without repeating the same patterns.</p>"},{"location":"notify/#what-it-does","title":"\u2728 What it does","text":"<p>Normally you would write: <pre><code>public class Person : INotifyPropertyChanged { private string _name;\npublic string Name\n{\n    get =&gt; _name;\n    set\n    {\n        if (_name == value) return;\n\n        _name = value;\n        OnPropertyChanged(nameof(Name));\n    }\n}\npublic event PropertyChangedEventHandler? PropertyChanged;\nprotected void OnPropertyChanged(string propertyName)\n    =&gt; PropertyChanged?.Invoke(this, new(propertyName));\n}\n</code></pre> With [Notify], you simply declare the backing field: <pre><code>public partial class Person \n{ \n    [Notify] \n    private string _name; \n} \n</code></pre> The generator creates the property, backing logic, and notification code automatically.</p>"},{"location":"notify/#benefits","title":"\ud83c\udfaf Benefits","text":"<p>No duplicated OnPropertyChanged code Strongly-typed, compiler-generated properties Easier refactoring (rename the field \u2192 property updates automatically) Less noise in your view-models</p>"},{"location":"notify/#generated-property","title":"\ud83d\udd0e Generated property","text":"<p>From the field: <code>[Notify] private string _name;</code> The generator produces something like: <pre><code>public string Name { \n    get =&gt; _name; \n    set \n    { \n        if (_name == value) return;\n        _name = value;\n        OnPropertyChanged(nameof(Name));\n    }\n} \n</code></pre> The exact output may vary slightly, but the behavior is always the same.</p>"},{"location":"notify/#notes","title":"\ud83d\udccc Notes","text":"<p>Works in any class marked partial Requires INotifyPropertyChanged support in your base type Generated code is placed in a .g.cs file \u2014 do not edit it</p>"},{"location":"notify/#how-notify-works","title":"\ud83d\udcc4 How Notify Works","text":"<p>When you mark a backing field with <code>[Notify]</code>, the generator:</p> <ul> <li>Ensures the type implements <code>INotifyPropertyChanged</code></li> <li>Generates a public property for the field</li> <li>Raises 'OnPropertyChanged' when the value changes</li> <li>Skips notifications when the value hasn\u2019t changed</li> <li>(Optional) generates strongly-typed change hooks</li> </ul> <p>If hooks are enabled for the field, the following methods are available:</p> <ul> <li><code>OnXChanging(oldValue, ref newValue, ref cancel)</code></li> <li><code>OnXChanged(oldValue, newValue)</code></li> </ul> <p>Use these to:</p> <ul> <li>validate and cancel changes</li> <li>modify the incoming value (coercion)</li> <li>react to changes after assignment</li> </ul> <p>The final property change event is raised only after the value is successfully updated.</p>"},{"location":"theme/","title":"Theme","text":""},{"location":"theme/#simple-code-first-theming","title":"Simple, code first theming","text":"<p>You can easily theme your entire app from a simple dictionTheme your entire app from a simple dictionary - no XAML resoource dictionaries to manage.</p> <p>Everything is generated and stays in code.</p>"},{"location":"theme/#getting-started","title":"Getting started","text":"<p>Create a public partial class, and add the <code>[Theme]</code> attribute and define your color dictionary.</p> <pre><code>[Theme]\npublic partial class AppTheme\n{\n    private static readonly Dictionary&lt;string, string&gt; _baseColors = new()\n    {\n        { \"Background\", \"#101010\" },\n        { \"Accent\", \"#505050\" },\n    };\n}\n</code></pre> <p>This generates</p> <ul> <li><code>ThemeColor</code> enum</li> <li><code>GetBrush()</code> </li> <li><code>GetColor()</code> </li> <li><code>SetColor()</code> </li> <li><code>ThemeBrush</code> XAML markup extension</li> </ul>"},{"location":"theme/#defaults","title":"Defaults","text":"<p>You don't have to define everything. A built-in palette is generated automatically - override only what you need:</p> <pre><code>public static readonly List&lt;(string Key, int A, int R, int G, int B)&gt; \n    BasePalette = new()\n    {\n        (\"Background\", 255, 30, 30, 30),\n        (\"Foreground\", 255, 220, 220, 220),\n        (\"Primary\",    255, 0, 120, 215),\n        (\"Secondary\",  255, 45, 45, 48),\n        (\"Accent\",     255, 0, 153, 204),\n        (\"Border\",     255, 90, 90, 90),\n        (\"Error\",      255, 232, 17, 35),\n        (\"Warning\",    255, 255, 185, 0),\n        (\"Success\",    255, 16, 124, 16)\n    };\n</code></pre>"},{"location":"theme/#basic-usage","title":"Basic usage","text":"<pre><code>&lt;Border Background=\"{local:ThemeBrush Base=Background}\"\n        BorderBrush=\"{local:ThemeBrush Base=Accent}\" /&gt;\n</code></pre>"},{"location":"theme/#advanced-usage","title":"Advanced usage","text":"<p>You can adjust alpha and brightness directly in XAML:</p> <pre><code>&lt;Border Background=\"{local:ThemeBrush Base=Background, Alpha=0.5}\"\n        BorderBrush=\"{local:ThemeBrush Base=Accent, Brightness=-50}\" /&gt;\n</code></pre> <ul> <li>Alpha - 0 (transparent) -&gt; 1 (opaque)</li> <li>Brightness - negative = darker, positive = lighter (clamped 0-255)</li> </ul>"},{"location":"theme/#runtime-theme-manipulation","title":"Runtime theme manipulation","text":"<p>Change colors at runtime - everything updates automatically:</p> <p><pre><code>AppTheme.SetColor(ThemeColor.Background, Colors.Blue);\n</code></pre> No resource dictionaries. No XAML updates. </p> <p>Just one line.</p>"}]}